---
title: "EKD11 Analysis"
author: "Chris Alder"
date: "08/11/2019"
output:
  html_document:
      toc: true
      number_sections: true
      toc_float: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

The Aim of the EKD11 timecourse experiment is to investigate the host's immune response to a primary _P.chabaudi AS_ infection transmitted through different routes; Natural transmission (Mosquito), serially blood passaged (SBP), and recently transmissited blood passage (RTMT). The timecourse looks at the acute phase of the infection, using transcriptomics data taken from days 1, 2, 3, 4 and 6.


# Pre-requisites

Loading the required R library packages and setting the directories for the project analysis
```{r workspace, include=FALSE}
source('/Users/alderc/1-projects/1-PIR_project/3-EKD11_AS_Early_TP/1-R/1-R_scripts/packages.R')

## Directories
nf.dir      <- "/Users/alderc/1-projects/CAMP/1-AS_timecourse/2-EKD11/1-Pipeline/1-Nextflow/";
work.dir    <- "/Users/alderc/1-projects/1-PIR_project/3-EKD11_AS_Early_TP/";
r.dir       <- paste(work.dir, "1-R/1-R_scripts/",sep='');
tmp.dir     <- paste(work.dir,"tmp/",sep='');
data.dir    <- paste(work.dir,"4-data/",sep='');
results.dir <- paste(work.dir,"2-results/",sep='')

for (dir in grep("\\.dir$",ls(),value=T)) {
  if (!file.exists(get(dir))) { dir.create(get(dir),recursive=TRUE, mode="0755"); }
}
```
# Experimental setup

## Loading Genome data

Importing GTF file containing genome information for Mus musculus. GRCm38 version 86

```{r gtf, include=FALSE}
genome.dir <- "~/1-projects/9-Data/1-Reference_genomes/1-Mus_musculus/";
genome     <- "GRCm38";
gtf.file   <- paste(genome.dir,"Mus_musculus.GRCm38.86.gtf",sep='');
gtf.meta    <- import(gtf.file);
gtf.dat    <- as.data.frame(gtf.meta[gtf.meta$type %in% "gene",]);
gtf.dat$GRCm38 <- paste("chr",gtf.dat$seqnames,":",gtf.dat$start,"-",gtf.dat$end,sep='');
rownames(gtf.dat) <- gtf.dat$gene_id;
```

## Design file

This is a file containing all the meta data we need for the data analysis. The important factors for the analysis are: sample, day, delivery, replicate and grp (group)


```{r design, echo=FALSE, results='asis'}
design.file <- paste(nf.dir,"design.csv",sep='');
design      <- read.delim(design.file,header=TRUE,sep=",", stringsAsFactors = TRUE);
rownames(design) <- design$label;
#sets naive to be first level of delivery
design$delivery  <- relevel(design$delivery,"naive");
#orders days in numerical order
design$day       <- factor(as.character(design$day),levels=as.character(sort(unique(design$day))));
design$replicate <- as.factor(design$replicate)

# create a copy of column grp2 and removes .day from naive set so relevel will order all naive as first
design$grp2      <- factor(sub("naive.*","naive",as.character(design$grp)));
design$grp2      <- relevel(design$grp2,"naive");

paged_table(design[ ,c(1,7:11)] , options = list(rows.print = 20))

```

## Importing count data and normalisation

This section will import the results of the RNA-seq pipeline and normalise the data according to library size. A count, log(counts) and TPM data frame will then we created from the normalised results.

Below is the TPM database from the experiment, calculated from RSEM.  
```{r counts, echo = FALSE}
txi <- tximport(paste(nf.dir,"results/rsem/",design$lims.name,".genes.results",sep=''), type="rsem")
txi$length[txi$length==0] <- 1

## Create DESeq2 object
dat <- DESeqDataSetFromTximport(txi, design, ~ grp) # To make Full rank model - Testing with controls removed to check for changes
rowData(dat) <- gtf.dat[rownames(dat),c("gene_id","gene_name","gene_source","gene_biotype","GRCm38")];

## Normalise / scale and stabilise variance
dds <- DESeq(dat);
vsd <- vst(dat, blind = TRUE);


#TPM function
tpm.calc <- function(counts) {
  gene.lengths <- gene.len[rownames(counts), 'length'] /1000
  x <- counts/gene.lengths
  return(t(t(x)*1e6/colSums(x)))
}

# Count, rlog and TPM data frames
count.norm  <- counts(dds,normalized=TRUE);
counts.df <- as.data.frame(count.norm)
vsd.db <- assay(vsd);
tpm.db <- as.data.frame(txi$abundance)
names(tpm.db) <- names(counts.df)

paged_table(tpm.db, options = list(rows.print = 10))
```


#PCA Plot 

PCA plot showing the separation of all samples within the study. The PCA is produced using top 1000 variable genes within the dataset.

```{r pca-3d}

rv <- rowVars(assay(vsd))
select <- order(rv, decreasing = TRUE)[1:1000]

pca <- prcomp(t(assay(vsd)[select, ]))
pca.sum <- summary(pca)
pca.val <- pca.sum$importance[2,1:3]
pca.df <- as.data.frame(pca$x[,1:3])
pca.df <- cbind(pca.df, design[rownames(pca.df), c("delivery", "day", "grp", "label")])
pca.cols <- c("mosquito" = "firebrick", "blood" = "darkblue", "naive" = "#E69F00", 'recent_blood' = 'forestgreen')

p <- plot_ly(data = pca.df) %>%
  add_trace(type = "scatter3d",
            x = ~PC1, y = ~PC2, z = ~PC3,
            color = ~delivery, colors = pca.cols,
            symbols = c("1" = "circle", "2" = "cross", "3" = "x", "4" = "square", "6" = "diamond"),
            text = ~label,
            mode = "markers",
            marker = list(size = 3)) %>% 
  add_trace(type = "scatter3d",
            x = ~PC1, y = ~PC2, z = ~PC3,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(color = "grey")) %>% 
  add_trace(type = "scatter3d",
            x = ~PC1, y = ~PC2, z = ~PC3,
            color = ~delivery,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            showlegend = F) %>% 
            layout(scene = list(xaxis = list(title = paste("PC1:", round(pca.val[[1]], 2)*100, "%", sep = " ")),
                                yaxis = list(title = paste("PC2:", round(pca.val[[2]], 2)*100, "%", sep = " ")),
                                zaxis = list(title = paste("PC2:", round(pca.val[[3]], 2)*100, "%", sep = " "))))

p
```

I've made the PCA in a 3D scatter plot to try and see if there is any separation of the samples before day 3 from PC3 that doesn't seem to appear when using just PC1 and PC2. PC3 only accounts for ~14% of the variance in the dataset, so I wasn't expecting a large change, nonetheless I think the separation it does show is worth keeping. I've also added 2D plots of PC1 vs PC2, PC1 vs PC3 and PC2 vs PC3, which may be more useful. 

```{r pca-1}
p.1 <- plot_ly(data = pca.df) %>%
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC2,
            color = ~delivery, colors = pca.cols,
            symbols = c("1" = "circle", "2" = "cross", "3" = "x", "4" = "square", "6" = "diamond"),
            text = ~label,
            mode = "markers") %>% 
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC2,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(color = "grey", size = 8)) %>% 
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC2,
            color = ~delivery,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(size = 10),
            showlegend = F) %>% 
            layout(xaxis = list(title = paste("PC1:", round(pca.val[[1]], 2)*100, "%", sep = " ")),
                   yaxis = list(title = paste("PC2:", round(pca.val[[2]], 2)*100, "%", sep = " ")))

p.1

```  

```{r pca-2}
p.2 <- plot_ly(data = pca.df) %>%
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC3,
            color = ~delivery, colors = pca.cols,
            symbols = c("1" = "circle", "2" = "cross", "3" = "x", "4" = "square", "6" = "diamond"),
            text = ~label,
            mode = "markers") %>% 
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC3,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(color = "grey", size = 8)) %>% 
  add_trace(type = "scatter",
            x = ~PC1, y = ~PC3,
            color = ~delivery,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(size = 10),
            showlegend = F) %>% 
            layout(xaxis = list(title = paste("PC1:", round(pca.val[[1]], 2)*100, "%", sep = " ")),
                   yaxis = list(title = paste("PC3:", round(pca.val[[3]], 2)*100, "%", sep = " ")))

p.2
```

```{r pca-3}
p.3 <- plot_ly(data = pca.df) %>%
  add_trace(type = "scatter",
            x = ~PC2, y = ~PC3,
            color = ~delivery, colors = pca.cols,
            symbols = c("1" = "circle", "2" = "cross", "3" = "x", "4" = "square", "6" = "diamond"),
            text = ~label,
            mode = "markers") %>% 
  add_trace(type = "scatter",
            x = ~PC2, y = ~PC3,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(color = "grey", size = 8)) %>% 
  add_trace(type = "scatter",
            x = ~PC2, y = ~PC3,
            color = ~delivery,
            symbol = ~day,
            mode = "markers",
            text = ~label,
            marker = list(size = 10),
            showlegend = F) %>% 
            layout(xaxis = list(title = paste("PC2:", round(pca.val[[2]], 2)*100, "%", sep = " ")),
                   yaxis = list(title = paste("PC3:", round(pca.val[[3]], 2)*100, "%", sep = " ")))

p.3

```

#Differential Gene Expression

##DGE overview

The PCA's may be indicating that, with the exception of day 1 of mosquito transmission, the groups are fairly homogeneous up to day 3. There are small clusters that form, however there seems to be one replicate in each group that bucks the trend in most cases. Doing direct group comparisons means that it's likely to mask siginficant genes each tranmission group uses to fight the infection. If we identify what genes are differentially expressed within each transmission route throughout the time course, and then compare these gene lists, we can see what genes are shared/different between the transmission routes. This will hide some information, such as if a gene/geneset are shared between two transmission routes, but activated at different times, but this approach will narrow down our search in the first instance. 

First of all we need to identify the DGE's in each transmission route, by comparing them to the controls.

```{r dge-res, include = F}
res.list <- list();
design(dds) <- ~ grp;
dds <- DESeq(dds);
resultsNames(dds);  
res.list[["mt.1_vs_naive"]]      <- results(dds, contrast=c("grp","mt.1","naive"));
res.list[["mt.2_vs_naive"]]      <- results(dds, contrast=c("grp","mt.2","naive"));
res.list[["mt.3_vs_naive"]]      <- results(dds, contrast=c("grp","mt.3","naive"));
res.list[["mt.4_vs_naive"]]      <- results(dds, contrast=c("grp","mt.4","naive"));
res.list[["mt.6_vs_naive"]]      <- results(dds, contrast=c("grp","mt.6","naive"));

res.list[["rtmt.1_vs_naive"]]      <- results(dds, contrast=c("grp","rtmt.1","naive"));
res.list[["rtmt.2_vs_naive"]]      <- results(dds, contrast=c("grp","rtmt.2","naive"));
res.list[["rtmt.3_vs_naive"]]      <- results(dds, contrast=c("grp","rtmt.3","naive"));
res.list[["rtmt.4_vs_naive"]]      <- results(dds, contrast=c("grp","rtmt.4","naive"));
res.list[["rtmt.6_vs_naive"]]      <- results(dds, contrast=c("grp","rtmt.6","naive"));

res.list[["sbp.1_vs_naive"]]      <- results(dds, contrast=c("grp","sbp.1","naive"));
res.list[["sbp.2_vs_naive"]]      <- results(dds, contrast=c("grp","sbp.2","naive"));
res.list[["sbp.3_vs_naive"]]      <- results(dds, contrast=c("grp","sbp.3","naive"));
res.list[["sbp.4_vs_naive"]]      <- results(dds, contrast=c("grp","sbp.4","naive"));
res.list[["sbp.6_vs_naive"]]      <- results(dds, contrast=c("grp","sbp.6","naive"));

res.list[['mt.1_vs_sbp.1']]      <- results(dds, contrast=c("grp","mt.1","sbp.1"));
res.list[['mt.2_vs_sbp.2']]      <- results(dds, contrast=c("grp","mt.2","sbp.2"));
res.list[['mt.3_vs_sbp.3']]      <- results(dds, contrast=c("grp","mt.3","sbp.3"));
res.list[['mt.4_vs_sbp.4']]      <- results(dds, contrast=c("grp","mt.4","sbp.4"));
res.list[['mt.6_vs_sbp.6']]      <- results(dds, contrast=c("grp","mt.6","sbp.6"));

res.list[['mt.1_vs_rtmt.1']]      <- results(dds, contrast=c("grp","mt.1","rtmt.1"));
res.list[['mt.2_vs_rtmt.2']]      <- results(dds, contrast=c("grp","mt.2","rtmt.2"));
res.list[['mt.3_vs_rtmt.3']]      <- results(dds, contrast=c("grp","mt.3","rtmt.3"));
res.list[['mt.4_vs_rtmt.4']]      <- results(dds, contrast=c("grp","mt.4","rtmt.4"));
res.list[['mt.6_vs_rtmt.6']]      <- results(dds, contrast=c("grp","mt.6","rtmt.6"));

res.list[['rtmt.1_vs_sbp.1']]      <- results(dds, contrast=c("grp","rtmt.1","sbp.1"));
res.list[['rtmt.2_vs_sbp.2']]      <- results(dds, contrast=c("grp","rtmt.2","sbp.2"));
res.list[['rtmt.3_vs_sbp.3']]      <- results(dds, contrast=c("grp","rtmt.3","sbp.3"));
res.list[['rtmt.4_vs_sbp.4']]      <- results(dds, contrast=c("grp","rtmt.4","sbp.4"));
res.list[['rtmt.6_vs_sbp.6']]      <- results(dds, contrast=c("grp","rtmt.6","sbp.6"));


## Filter results
res.list <- lapply(res.list,function(res){
  res <- as.data.frame(res);
  colnames(res)[colnames(res) %in% "log2FoldChange"] <- "log2FC";
  colnames(res)[colnames(res) %in% "padj"] <- "FDR";
  res$DEG <- res$FDR <= 0.05 &
    abs(res$log2FC)>= 1 & #only filters out logFC Â±1
    res$baseMean>=30         &
    !is.na(res$log2FC)       &
    !is.na(res$FDR);
  res;
})
deg.meta <- as.data.frame(cbind(sapply(res.list[1:15],function(x){sum(x$DEG)})))
names(deg.meta) <- "No. DEG"

deg.meta
```

With the comparisons made and genes filtered to identify the DGE's we can see how many genes were identified within in each group.

```{r deg-table}
paged_table(deg.meta, options = list(rows.print = 15))
```

We can then find out the total number of genes used by each transmission group throughout the timecourse.
```{r deg-total}
# Mosquito vs Naive results and DEG
mvn.res <- res.list[grep('^mt.._vs_naive', names(res.list))]
mvn.deg <- lapply(mvn.res, function(df){return(df[df$DEG,])})

# Recently MT vs Naive results and DEG
rtvn.res <- res.list[grep('^rtmt.._vs_naive', names(res.list))]
rtvn.deg <- lapply(rtvn.res, function(df){return(df[df$DEG,])})

# SBP vs Naive results and DEG 
svn.res <- res.list[grep('^sbp.._vs_naive', names(res.list))]
svn.deg <- lapply(svn.res, function(df){return(df[df$DEG,])})

# Genes involved in each transmission route
mt.genes <- unique(unlist(sapply(mvn.deg, row.names)))
rtmt.genes <- unique(unlist(sapply(rtvn.deg, row.names))) 
sbp.genes <- unique(unlist(sapply(svn.deg, row.names))) 
total.genes <- unique(do.call(c, list(mt.genes, rtmt.genes, sbp.genes)))

# Common genes involved in each transmission response
common.genes <- Reduce(intersect, list(mt.genes, rtmt.genes, sbp.genes))


print(paste("MT:", length(mt.genes), "differntially expressed genes identified"))
print(paste("RTMT:", length(rtmt.genes), "differentially expressed genes identified"))
print(paste("SBP:", length(sbp.genes), "differentially expressed genes identified"))
print(paste("Total number of differentially expressed genes identified across all groups: ", length(total.genes), "genes"))

```

##Venn diagram 

There seems to be a significant difference in the number of DGE's between the transmission groups, which is to be expected, especially between SBP and both MT and RTMT. By the total number of unique DGE's found across all groups, it is apparent that many of the genes identified are shared between two or more groups. We can construct a Venn diagram to see how the 2971 are divided across the transmission routes and see what is shared or unique between each route. 

```{r venn}
library("VennDiagram")
venn.cols <- c("firebrick", "darkblue", "forestgreen")
venn <- venn.diagram(x = list(mt.genes, sbp.genes, rtmt.genes),
                     category.names = c("MT", "SBP", "RTMT"),
                     filename = NULL,
                     
                     #Circles
                     lwd = 2,
                     lty = "blank",
                     fill = venn.cols,
                     
                     # Numbers
                     fontface = "bold",
                     fontfamily = "sans",
                     
                     # Set names
                     cat.fontface = "bold",
                     cat.default.pos = "outer",
                     cat.pos = c(-27, 27, 135),
                     cat.dist = c(0.055, 0.055, 0.085),
                     cat.fontfamily = "sans",
                     rotation = 1);
grid.newpage()
grid.draw(venn)
```

The venn diagram tells us a lot of information about the transmission routes. For example it shows us that a lot of the DGE's identified across the transmission groups are shared between them. One particular intersection that I think is of interest is the 303 genes that are shared between MT and RTMT, but not with SBP. If MT and RTMT share the same phenotype, which shows a greater level of attenuation of parasataemia, maybe the genes that drive this are within this set?

Whilst the venn diagram does give us a broad overview of the interplay of these groups and there DGE's, it is hiding some resolution within the data. First of all, the diagram was constructed by identifying DGE's within each transmission group but doesn't take into account whether the gene was up or downregulated in respect to the Naive. This means that whilst a gene could be shared between two or more groups, it could upregualted in one whilst downregulated in another. Another key factor the venn diagram masks is the day the gene was first identified as differentially expressed in the groups. The earlier activation of the immune response is likely to be a key factor in the control of the infection, so a way to investigate this is required. 

The issued raise in regards to the lack of information on up/down-regulated genes can be done just by separating out these genes and constructing two additional diagrams.

First of all, we need to identify seperate out the up/down-regulated DGE's from the lists we identified



```{r up-down-reg}
# MT up
mt.up <- unique(unlist(sapply(mvn.deg, function(df){
  tmp <- df[df$log2FC > 0, ]
  rownames(tmp)
})))
# MT down
mt.down <- unique(unlist(sapply(mvn.deg, function(df){
  tmp <- df[df$log2FC < 0, ]
  rownames(tmp)
})))

# RTMT up
rtmt.up <- unique(unlist(sapply(rtvn.deg, function(df){
  tmp <- df[df$log2FC > 0, ]
  rownames(tmp)
})))
# RTMT down
rtmt.down <- unique(unlist(sapply(rtvn.deg, function(df){
  tmp <- df[df$log2FC < 0, ]
  rownames(tmp)
})))

# SBP up
sbp.up <- unique(unlist(sapply(svn.deg, function(df){
  tmp <- df[df$log2FC > 0, ]
  rownames(tmp)
})))
# SBP down
sbp.down <- unique(unlist(sapply(svn.deg, function(df){
  tmp <- df[df$log2FC < 0, ]
  rownames(tmp)
})))

print(paste("MT:", length(mt.genes), "DGE identified"))
print(paste("MT:", length(mt.up), "Upregualted genes identified"))
print(paste("MT:", length(mt.down), "Downregualted genes identified"))

print(paste("RTMT:", length(rtmt.genes), "DGE genes identified"))
print(paste("RTMT:", length(rtmt.up), "Upregulated genes identified"))
print(paste("RTMT:", length(rtmt.down), "Downregulated genes identified"))

print(paste("SBP:", length(sbp.genes), "DGE genes identified"))
print(paste("SBP:", length(sbp.up), "Upregulated genes identified"))
print(paste("SBP:", length(sbp.down), "Downregulated genes identified"))

```

With the groups separated into their up/down regualted genes, we can construct separate Venn diagrams for each one. 



```{r venn-up}
venn <- venn.diagram(x = list(mt.up, sbp.up, rtmt.up),
                     category.names = c("MT", "SBP", "RTMT"),
                     filename = NULL,
                     
                     #Title
                     main = "Upregulated genes",
                     main.fontface = "bold",
                     main.fontfamily = "sans",                     

                     #Circles
                     lwd = 2,
                     lty = "blank",
                     fill = venn.cols,

                     # Numbers
                     fontface = "bold",
                     fontfamily = "sans",

                     # Set names
                     cat.fontface = "bold",
                     cat.default.pos = "outer",
                     cat.pos = c(-27, 27, 135),
                     cat.dist = c(0.055, 0.055, 0.085),
                     cat.fontfamily = "sans",
                     rotation = 1);
grid.newpage()
grid.draw(venn)
```



```{r venn-down}
venn <- venn.diagram(x = list(mt.down, sbp.down, rtmt.down),
                     category.names = c("MT", "SBP", "RTMT"),
                     filename = NULL,
                     
                     #Title
                     main = "Downregulated genes",
                     main.fontface = "bold",
                     main.fontfamily = "sans",

                     #Circles
                     lwd = 2,
                     lty = "blank",
                     fill = venn.cols,

                     # Numbers
                     fontface = "bold",
                     fontfamily = "sans",

                     # Set names
                     cat.fontface = "bold",
                     cat.default.pos = "outer",
                     cat.pos = c(-27, 27, 135),
                     cat.dist = c(0.055, 0.055, 0.085),
                     cat.fontfamily = "sans",
                     rotation = 1);
grid.newpage()
grid.draw(venn)
```

## RTMT vs MT - shared genes

### heatmap overview

With the identification of DGE's shared between MT and RTMT, we can start to investigate further this geneset. First of all, a heatmap of these genes will be helpful in identifying any expression trends between the groups. First of all we'll use TPM's to construct the heatmap. 

```{r heatmap}
# Genes shared by MT and RTMT, not used in SBP 
mt.rtmt.genes <- intersect(mt.genes, rtmt.genes)
mt.rtmt.genes <- setdiff(mt.rtmt.genes, common.genes)
heat.genes <- mt.rtmt.genes

heat.dat   <- as.matrix(tpm.db[heat.genes,]);
heat.dat <- (log(heat.dat+1))
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];

#order so days are together 
heat.list <- colnames(heat.dat);
heat.list <- as.data.frame(heat.list);
heat.list$day <- ifelse(grepl("naive", heat.list$heat.list),
                        0,
                        str_match(string=heat.list$heat.list, pattern= "\\.d(.+)\\.")[,2]);
heat.list$delivery <- ifelse(grepl("naive", heat.list$heat.list),
                             "naive",
                             str_match(string=heat.list$heat.list, pattern="^(.*)\\..*\\.")[,2]);
heat.list$delivery <- ordered(factor(heat.list$delivery, levels= c('naive', 'sbp', 'rtmt', 'mt')))
heat.list$rep <- as.integer(str_match(string=heat.list$heat.list, pattern=".*r(.)$")[,2]);
heat.list <- heat.list[order(as.numeric(heat.list$day), as.numeric(as.factor(heat.list$delivery)), heat.list$rep),];
heat.list
heat.list <- as.vector(heat.list$heat.list);


heat.dat <- heat.dat[,heat.list] # Use the same col order as the for the zscore heatmap


ht <- Heatmap(heat.dat,
              name = "log(tpm+1)",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = viridis::viridis(100));

ht
groups <-  c(0, seq(4,64,12))
decorate_heatmap_body('log(tpm+1)', c(for(d in seq(0, length(heat.list), 4)){
  ifelse(d %in% groups, x <- 'solid', x <- 'dashed')
  grid.lines(x=c(d/64, d/64), y=c(0,1), gp= gpar(col = 'black', lty=x, lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)


```

Using TPMs hides a lot of pattern information, as only a few individual genes have such a high expression that it widens the scale of the heatmap, even when using log(TPM). 

Z-scores, which measures how far a samples gene expression (in SD) is from the mean across all samples may be a better solution, as it normalises the data to account relative levels of expressions for a gene, and better highlights the variation between samples. 

```{r heatmap-tpm}

# Heatmap of RTMT + MT genes genes

heat.dat   <- as.matrix(assay(vsd)[heat.genes,]);
heat.dat   <- t(apply(heat.dat,1,function(x){((x-mean(x,na.rm=TRUE))/sd(x,na.rm=TRUE))}));
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];


heat.dat <- heat.dat[,heat.list];
ht <- Heatmap(heat.dat,
              name = "zscore",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = colorRamp2(c(-3.5, 0, 3.5), rev(colorRampPalette(brewer.pal(9, "RdBu"))(3))));


ht
groups <-  c(0, seq(4,64,12))
decorate_heatmap_body('zscore', c(for(d in seq(0, length(heat.list), 4)){
  ifelse(d %in% groups, x <- 'solid', x <- 'dashed')
  grid.lines(x=c(d/64, d/64), y=c(0,1), gp= gpar(col = 'black', lty=x, lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)
```

##Day 4
```{r}
res.d4 <- res.list[grep("4_vs_naive", names(res.list))]
deg.d4 <- unique(unlist(sapply(res.d4, function(df){
  df <- df[df$DEG, ]
  rownames(df)
})))

rtmt.d4 <- res.d4[[2]]
rtmt.d4 <- rtmt.d4[rtmt.d4$DEG, ]

sbp.d4 <- res.d4[[3]]
sbp.d4 <- sbp.d4[sbp.d4$DEG, ]

mt.d4 <- res.d4[[1]]
mt.d4 <- mt.d4[mt.d4$DEG, ]

non.mt <- setdiff(deg.d4, rownames(mt.d4))
# non.mt <- gtf.dat[non.mt, "gene_name"]

rvs.common <- intersect(rownames(sbp.d4), rownames(rtmt.d4))
rvs.r.only <- setdiff(rownames(rtmt.d4), rvs.common)
rvs.s.only <- setdiff(rownames(sbp.d4), rvs.common)
rvs.d4.all <- unique(append(rownames(sbp.d4), rownames(rtmt.d4)))
rvs.d4.all.pc <- intersect(rvs.d4.all, gtf.dat$gene_id[gtf.dat$gene_biotype %in% "protein_coding"])

deg.d4.pc <- intersect(deg.d4,gtf.dat$gene_id[gtf.dat$gene_biotype %in% "protein_coding"])
heat.genes <- rvs.d4.all.pc

# Heatmap of RTMT + MT genes genes

heat.dat   <- as.matrix(assay(vsd)[heat.genes,]);
heat.dat   <- heat.dat[, grep("naive|d4", colnames(heat.dat))]
heat.dat   <- t(apply(heat.dat,1,function(x){((x-mean(x,na.rm=TRUE))/sd(x,na.rm=TRUE))}));
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];
heat.dat


#order so days are together 
heat.list <- colnames(heat.dat);
heat.list <- as.data.frame(heat.list);
heat.list$day <- ifelse(grepl("naive", heat.list$heat.list),
                        0,
                        str_match(string=heat.list$heat.list, pattern= "\\.d(.+)\\.")[,2]);
heat.list$delivery <- ifelse(grepl("naive", heat.list$heat.list),
                             "naive",
                             str_match(string=heat.list$heat.list, pattern="^(.*)\\..*\\.")[,2]);
heat.list$delivery <- ordered(factor(heat.list$delivery, levels= c('naive', 'sbp', 'rtmt', 'mt')))
heat.list$rep <- as.integer(str_match(string=heat.list$heat.list, pattern=".*r(.)$")[,2]);
heat.list <- heat.list[order(as.numeric(heat.list$day), as.numeric(as.factor(heat.list$delivery)), heat.list$rep),];
heat.list
heat.list <- as.vector(heat.list$heat.list);
heat.dat <- heat.dat[,heat.list];


ht <- Heatmap(heat.dat,
              name = "zscore",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = colorRamp2(c(min(heat.dat)-0.5, 0, max(heat.dat)+0.5), rev(colorRampPalette(brewer.pal(9, "RdBu"))(3))));

ht
decorate_heatmap_body('zscore', c(for(d in seq(0, length(heat.list), 4)){
  grid.lines(x=c(d/length(heat.list), d/length(heat.list)), y=c(0,1), gp= gpar(col = 'black', lty = "solid", lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)
```

##Day 3
```{r}
res.d3 <- res.list[grep("3_vs_naive", names(res.list))]
deg.d3 <- unique(unlist(sapply(res.d3, function(df){
  df <- df[df$DEG, ]
  rownames(df)
})))

rtmt.d3 <- res.d3[[2]]
rtmt.d3 <- rtmt.d3[rtmt.d3$DEG, ]

sbp.d3 <- res.d3[[3]]
sbp.d3 <- sbp.d3[sbp.d3$DEG, ]

mt.d3 <- res.d3[[1]]
mt.d3 <- mt.d3[mt.d3$DEG, ]

non.mt <- setdiff(deg.d3, rownames(mt.d3))
# non.mt <- gtf.dat[non.mt, "gene_name"]

rvs.common <- intersect(rownames(sbp.d3), rownames(rtmt.d3))
rvs.r.only <- setdiff(rownames(rtmt.d3), rvs.common)
rvs.s.only <- setdiff(rownames(sbp.d3), rvs.common)
rvs.d3.all <- unique(append(rownames(sbp.d3), rownames(rtmt.d3)))
rvs.d3.all.pc <- intersect(rvs.d3.all, gtf.dat$gene_id[gtf.dat$gene_biotype %in% "protein_coding"])

deg.d3.pc <- intersect(deg.d3,gtf.dat$gene_id[gtf.dat$gene_biotype %in% "protein_coding"])
heat.genes <- deg.d3.pc 

# Heatmap of RTMT + MT genes genes

heat.dat   <- as.matrix(assay(vsd)[heat.genes,]);
heat.dat   <- heat.dat[, grep("naive|d3", colnames(heat.dat))]
heat.dat   <- t(apply(heat.dat,1,function(x){((x-mean(x,na.rm=TRUE))/sd(x,na.rm=TRUE))}));
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];
heat.dat


#order so days are together 
heat.list <- colnames(heat.dat);
heat.list <- as.data.frame(heat.list);
heat.list$day <- ifelse(grepl("naive", heat.list$heat.list),
                        0,
                        str_match(string=heat.list$heat.list, pattern= "\\.d(.+)\\.")[,2]);
heat.list$delivery <- ifelse(grepl("naive", heat.list$heat.list),
                             "naive",
                             str_match(string=heat.list$heat.list, pattern="^(.*)\\..*\\.")[,2]);
heat.list$delivery <- ordered(factor(heat.list$delivery, levels= c('naive', 'sbp', 'rtmt', 'mt')))
heat.list$rep <- as.integer(str_match(string=heat.list$heat.list, pattern=".*r(.)$")[,2]);
heat.list <- heat.list[order(as.numeric(heat.list$day), as.numeric(as.factor(heat.list$delivery)), heat.list$rep),];
heat.list
heat.list <- as.vector(heat.list$heat.list);
heat.dat <- heat.dat[,heat.list];


ht <- Heatmap(heat.dat,
              name = "zscore",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = colorRamp2(c(min(heat.dat)-0.5, 0, max(heat.dat)+0.5), rev(colorRampPalette(brewer.pal(9, "RdBu"))(3))));

ht
decorate_heatmap_body('zscore', c(for(d in seq(0, length(heat.list), 4)){
  grid.lines(x=c(d/length(heat.list), d/length(heat.list)), y=c(0,1), gp= gpar(col = 'black', lty = "solid", lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)
```

##Ifng
```{r}
deg.list <- lapply(res.list[1:15], function(df){
  df <- df[df$DEG, ]
  df
})

#IFNG plot
ifng.id <- gtf.dat$gene_id[gtf.dat$gene_name %in% "Ifng"]
ifng.id
cnt.dat  <- plotCounts(dds, which(rownames(dds) %in% ifng.id), intgroup = c("day","delivery"), returnData = TRUE);
#cnt.dat$day <- as.numeric(as.character(cnt.dat$day))
cnt.plot <- ggplot(cnt.dat, aes(x = day, y = count, color = delivery, fill=delivery, group = delivery)) + geom_point() + geom_smooth(se = FALSE, method = "loess", span = 0.75);
cnt.plot <- cnt.plot + ggtitle("Ifng") + ylab("normalised count") + xlab("day");
#cnt.plot <- cnt.plot + scale_y_log10();
cnt.cols <- c("mosquito" = "firebrick", "blood" = "darkblue", "naive" = "#E69F00", 'recent_blood' = 'forestgreen')
cnt.plot <- cnt.plot + scale_colour_manual(values = pca.cols)
print(cnt.plot);
cnt.dat
```

```{r}

ifng.deg <- deg.list[c(3:5, 9:10, 14:15)]

ifng.deg.list <- unique(unlist(sapply(ifng.deg, row.names)))
# write.table(x = ifng.deg.list,
#             file = paste(results.dir, "ifng.deg.txt", sep =""),
#             sep = "\t",
#             row.names = F,
#             quote = F)
interferome.res <- read.table(file = paste(results.dir, "Interferome_results.txt" , sep = ""),
                              sep = "\t",
                              header = T,
                              row.names = NULL,
                              quote = "")

interferome.res.id <- interferome.res$Ensembl.Id

mvn.interferome <- deg.list[3:5]
mvn.interferome <- lapply(mvn.interferome, function(df){
  df <- df[interferome.res.id, ] %>% 
    drop_na()
  df
})
mvn.interferome.list <- unique(unlist(sapply(mvn.interferome, row.names)))

rvn.interferome <- deg.list[9:10]
rvn.interferome <- lapply(rvn.interferome, function(df){
  df <- df[interferome.res.id, ] %>% 
    drop_na()
  df
})
rvn.interferome.list <- unique(unlist(sapply(rvn.interferome, row.names)))

svn.interferome <- deg.list[14:15]
svn.interferome <- lapply(svn.interferome, function(df){
  df <- df[interferome.res.id, ] %>% 
    drop_na()
  df
})
svn.interferome.list <- unique(unlist(sapply(svn.interferome, row.names)))
length(mvn.interferome.list)
length(rvn.interferome.list)
length(svn.interferome.list)

mt.rtmt.isg.common <- intersect(mvn.interferome.list, rvn.interferome.list)

isg.setdiff.sbp <- setdiff(mt.rtmt.isg.common, svn.interferome.list)

rvn.interferome
```
##Heatmap of ISGs unique to MT and RTMT
```{r}

heat.genes <- isg.setdiff.sbp

heat.dat   <- as.matrix(assay(vsd)[heat.genes,]);
heat.dat   <- heat.dat[, grep("naive|d6", colnames(heat.dat))]
heat.dat   <- t(apply(heat.dat,1,function(x){((x-mean(x,na.rm=TRUE))/sd(x,na.rm=TRUE))}));
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];
heat.dat


#order so days are together 
heat.list <- colnames(heat.dat);
heat.list <- as.data.frame(heat.list);
heat.list$day <- ifelse(grepl("naive", heat.list$heat.list),
                        0,
                        str_match(string=heat.list$heat.list, pattern= "\\.d(.+)\\.")[,2]);
heat.list$delivery <- ifelse(grepl("naive", heat.list$heat.list),
                             "naive",
                             str_match(string=heat.list$heat.list, pattern="^(.*)\\..*\\.")[,2]);
heat.list$delivery <- ordered(factor(heat.list$delivery, levels= c('naive', 'sbp', 'rtmt', 'mt')))
heat.list$rep <- as.integer(str_match(string=heat.list$heat.list, pattern=".*r(.)$")[,2]);
heat.list <- heat.list[order(as.numeric(heat.list$day), as.numeric(as.factor(heat.list$delivery)), heat.list$rep),];
heat.list
heat.list <- as.vector(heat.list$heat.list);
heat.dat <- heat.dat[,heat.list];


ht <- Heatmap(heat.dat,
              name = "zscore",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = colorRamp2(c(min(heat.dat)-0.5, 0, max(heat.dat)+0.5), rev(colorRampPalette(brewer.pal(9, "RdYlBu"))(3))));

ht
decorate_heatmap_body('zscore', c(for(d in seq(0, length(heat.list), 4)){
  grid.lines(x=c(d/length(heat.list), d/length(heat.list)), y=c(0,1), gp= gpar(col = 'black', lty = "solid", lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)
```

## ISGs SBP and RTMT Day 4
```{r}
rvn.interferome.d4 <- rownames(rvn.interferome[[1]])
svn.interferome.d4 <- rownames(svn.interferome[[1]])

sbp.rtmt.isg.d4 <- append(rvn.interferome.d4, svn.interferome.d4)

heat.genes <- sbp.rtmt.isg.d4

heat.dat   <- as.matrix(assay(vsd)[heat.genes,]);
heat.dat   <- heat.dat[, grep("naive|d4", colnames(heat.dat))]
heat.dat   <- t(apply(heat.dat,1,function(x){((x-mean(x,na.rm=TRUE))/sd(x,na.rm=TRUE))}));
rownames(heat.dat) <- gtf.dat[heat.genes,"gene_name"];
heat.dat


#order so days are together 
heat.list <- colnames(heat.dat);
heat.list <- as.data.frame(heat.list);
heat.list$day <- ifelse(grepl("naive", heat.list$heat.list),
                        0,
                        str_match(string=heat.list$heat.list, pattern= "\\.d(.+)\\.")[,2]);
heat.list$delivery <- ifelse(grepl("naive", heat.list$heat.list),
                             "naive",
                             str_match(string=heat.list$heat.list, pattern="^(.*)\\..*\\.")[,2]);
heat.list$delivery <- ordered(factor(heat.list$delivery, levels= c('naive', 'sbp', 'rtmt', 'mt')))
heat.list$rep <- as.integer(str_match(string=heat.list$heat.list, pattern=".*r(.)$")[,2]);
heat.list <- heat.list[order(as.numeric(heat.list$day), as.numeric(as.factor(heat.list$delivery)), heat.list$rep),];
heat.list
heat.list <- as.vector(heat.list$heat.list);
heat.dat <- heat.dat[,heat.list];


ht <- Heatmap(heat.dat,
              name = "zscore",
              show_row_names          = TRUE,
              show_column_names       = TRUE,
              column_names_side       = "bottom",
              show_column_dend        = FALSE,
              cluster_columns         = FALSE,
              rect_gp                 = gpar(col = "white", lwd = 1),
              row_dend_width          = unit(30, "mm"),
              column_dend_height      = unit(30, "mm"),
              show_heatmap_legend     = TRUE,
              clustering_distance_rows = 'pearson',
              column_names_max_height = unit(8, "cm"),
              row_names_gp            = gpar(fontsize = 6),
              column_names_gp         = gpar(fontsize = 10),
              # split                   = split.vec, #This would use vector I created above to split and cluster the genes
              # top_annotation          = ha1,
              # bottom_annotation       = anno_bottom,
              col                     = colorRamp2(c(min(heat.dat)-0.5, 0, max(heat.dat)+0.5), rev(colorRampPalette(brewer.pal(9, "RdBu"))(3))));

ht
decorate_heatmap_body('zscore', c(for(d in seq(0, length(heat.list), 4)){
  grid.lines(x=c(d/length(heat.list), d/length(heat.list)), y=c(0,1), gp= gpar(col = 'black', lty = "solid", lwd=2))},
  grid.lines(y=c(0,0), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2)),
  grid.lines(y=c(1,1), x=c(0,1), gp= gpar(col = 'black', lty='solid', lwd=2))), slice = 1)
```


```{r}
isg.calc <- function(df.list) {
  df.
}



(sapply(deg.list[14:15], function(df){
   x <- nrow(df)
   y <- df[interferome.res.id, ] %>% drop_na()
   y <- length(rownames(y))
   return(c(x,y, y/x))
}))


mvn.interferome

mvn.deg <- unique(unlist(sapply(res.list[1:3], function(df){
  df <- df[df$DEG, ]
  rownames(df)
})))
(gtf.dat[mvn.deg, "gene_name"])
```






